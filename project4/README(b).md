# SM3哈希函数长度扩展攻击实验报告

## 一、实验背景与目的

SM3是我国自主设计的密码哈希算法标准，广泛应用于各类安全系统中。本次实验旨在通过构造具体的长度扩展攻击案例，验证SM3算法在特定使用场景下存在的安全风险。实验将完整展示攻击者如何在不获取原始消息内容的情况下，仅凭已知的哈希值和消息长度，成功构造出包含恶意扩展数据的合法哈希值。

## 二、实验环境配置

实验在Windows 10操作系统下完成，使用Visual Studio 2019作为开发环境，编译平台为x64 Debug模式。核心算法实现基于C++11标准，不依赖第三方密码库。

## 三、攻击原理详解

长度扩展攻击的本质是利用Merkle-Damgård结构的以下特性：

1. **状态延续性**：哈希计算过程是迭代进行的，每个消息块的处理都会更新内部状态寄存器。最终的哈希值实际上是最后时刻的状态寄存器值的拼接。

2. **状态可逆性**：对于输出长度为256位的SM3算法，其最终哈希值由8个32位的状态寄存器（H0-H7）直接构成。这意味着可以从哈希值精确还原出计算结束时的完整内部状态。

3. **填充可预测性**：SM3采用标准的填充方式（先补1再补0最后附加消息长度），攻击者可以根据原始消息长度准确推算出填充内容。

## 四、完整实验过程

### 4.1 初始数据准备

选择测试消息和扩展内容：

```cpp
const char* original_msg = "This is a secret message";
const char* extension = "malicious extension";
```

## 4.2 攻击实施关键步骤

### 步骤1：状态寄存器恢复

将256位哈希值拆分为8个32位状态值：

```cpp
uint32_t H[8];
for(int i=0; i<8; i++) {
    H[i] = (hash[i*4]<<24) | (hash[i*4+1]<<16)
          | (hash[i*4+2]<<8) | hash[i*4+3];
}
```

### 步骤2：填充长度计算

根据SM3规范计算原始消息的填充后长度：

```cpp
size_t padded_len = ((orig_len + 8 + 63)/64)*64;
```

### 步骤3：恶意消息构造

构建符合SM3填充规范的新消息结构：

```cpp
vector<uint8_t> new_msg(padded_len + ext_len + 64);
// 在原始填充位置开始写入扩展内容
memcpy(&new_msg[padded_len], extension, ext_len);
// 添加新消息的填充
new_msg[new_len] = 0x80;  // 补1操作
uint64_t bit_len = (padded_len + ext_len)*8;
for(int i=0; i<8; i++) {
    new_msg[new_padded_len-8+i] = (bit_len >> (56-i*8)) & 0xff;
}

```

### 4.3 实验结果展示


## 五、实验结论与启示
本次实验成功验证了SM3算法在直接用于消息认证码(MAC)构造时存在严重的安全隐患。这提醒我们在实际工程应用中必须注意：

密码学原语的安全使用方式与算法本身同样重要

系统设计时应进行完整的安全威胁建模

对重要系统应定期进行安全性审计

该实验结果不仅适用于SM3算法，对采用类似结构的SHA-1、MD5等哈希函数同样具有参考价值。

