# SM4加密算法优化实验报告

## 1. 优化背景

SM4是中国国家标准的一种分组密码算法，广泛应用于各种安全场景。原始实现存在以下性能瓶颈：
- S盒替换和线性变换L的实时计算开销大
- 频繁的字节与字转换操作
- 内存访问效率不高

## 2. 优化思路

### 2.1 T-table预计算优化

| 优化方法 | 实现细节 | 预期收益 |
|---------|---------|---------|
| **S盒与线性变换合并** | 将S盒替换和线性变换L合并为查找表 | 消除实时计算开销 |
| **256项预计算表** | 为每个可能的字节输入(0-255)预计算输出 | 减少90%以上的T函数计算时间 |
| **32位字操作** | 直接操作32位字而非字节数组 | 减少内存访问次数 |

### 2.2 轮函数优化

| 优化方法 | 实现细节 | 预期收益 |
|---------|---------|---------|
| **查表代替计算** | 使用T-table实现快速非线性变换 | 单次查表仅需1-3个CPU周期 |
| **循环部分展开** | 每轮处理4个步骤 | 减少分支预测开销 |
| **寄存器优化** | 保持中间结果在寄存器中 | 减少内存访问 |

### 2.3 整体流程优化

| 优化方法 | 实现细节 | 预期收益 |
|---------|---------|---------|
| **批量字转换** | 输入/输出时集中处理字节-字转换 | 减少转换开销 |
| **流水线友好设计** | 顺序数据访问模式 | 提高CPU流水线效率 |
| **早期初始化** | 程序启动时初始化T-table | 避免运行时初始化延迟 |

## 3. 关键代码实现

### 3.1 T-table初始化

```cpp
void init_T_table() {
    for (int i = 0; i < 256; ++i) {
        uint8_t b = Sbox[i];
        uint32_t word = b << 24;
        uint32_t L = word ^ rol(word,2) ^ rol(word,10) 
                    ^ rol(word,18) ^ rol(word,24);
        T_table[i] = L;
    }
}
```

### 3.2 优化后的T函数

```cpp
uint32_t T_func_optimized(uint32_t word) {
    return T_table[(word >> 24) & 0xFF] ^
           rol(T_table[(word >> 16) & 0xFF], 8) ^
           rol(T_table[(word >> 8) & 0xFF], 16) ^
           rol(T_table[word & 0xFF], 24);
}
```
### 3.3 优化后的加密流程

```cpp
void SM4Encrypt_optimized(const uint8_t* input, uint8_t* output, 
                         const uint32_t rk[32]) {
    // 初始化状态字
    uint32_t x[36];
    x[0] = load_be32(input);
    x[1] = load_be32(input+4);
    x[2] = load_be32(input+8);
    x[3] = load_be32(input+12);
    
    // 32轮加密(部分展开)
    for (int i = 0; i < 32; i += 4) {
        x[i+4] = x[i] ^ T_func_optimized(x[i+1]^x[i+2]^x[i+3]^rk[i]);
        // 后续3轮类似...
    }
    
    // 反序输出
    store_be32(output, x[35]);
    store_be32(output+4, x[34]);
    // ...其余输出
}
```

## 4. 实验结果

![功能验证截图](屏幕截图%202025-08-07%20113705.png "加解密结果")
### 4.1 功能验证
| 测试项       | 结果（十六进制）                     |
|--------------|-------------------------------------|
| **加密结果** | c0 42 51 9d cf d1 dd 43 66 fb e4 5e 1b b9 20 2d |
| **解密结果** | 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 |

> 验证说明：解密结果与原始输入完全一致，证明算法实现正确

### 4.2 性能对比

#### 单次操作延迟（纳秒级）
| 操作类型 | 优化前    | 优化后    | 加速比  |
|----------|-----------|-----------|---------|
| 加密     | 3231.40 ns | 332.50 ns | 9.72x   |
| 解密     | 3023.78 ns | 303.96 ns | 9.95x   |

#### 吞吐量测试（1MB数据）
| 操作类型 | 优化前   | 优化后    | 提升幅度 |
|----------|----------|-----------|---------|
| 加密     | 6.67 MB/s | 44.61 MB/s | 569%    |
| 解密     | 7.24 MB/s | 42.52 MB/s | 487%    |

### 4.3 关键性能指标
1. **延迟降低**：单次操作时间缩短至约1/10
2. **吞吐提升**：加密/解密速度提升约5-6倍
3. **稳定性**：加解密性能提升幅度基本一致

## 5. 实验结论

1. **功能正确性**：优化前后算法输出结果一致，加解密功能验证通过
2. **显著性能提升**：
   - 平均单次操作时间从约3μs降至300ns级别
   - 吞吐量从6-7MB/s提升至42-44MB/s
3. **优化有效性**：T-table优化方案使SM4算法性能提升近一个数量级
4. **实际应用价值**：优化后性能可满足大多数实时加密场景需求
